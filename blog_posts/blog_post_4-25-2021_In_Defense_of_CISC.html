<!DOCTYPE html>
<html lang="en">

<head>
    <title>Blog</title>
    <meta lang="en" charset="UTF-8">
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
    <!-- Font Awesome icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <!-- Ensure proper mobile and desktop bootstrap rendering -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- jQuery library -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <!-- Popper JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"></script>
    <!-- Latest compiled JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>
    <!-- Custum Javascript rules for this site -->
    <script src="../rules.js"></script>
    <!-- Personal stylesheet -->
    <link rel="stylesheet" href="../dchid.css">
</head>

<body style="background-color: black;">
    <div class="terminal">
        <div class="start_terminal"></div>
	<p class="blog_paragraph">In a previous blog post, I talked about the differences between reduced instruction set computing or “RISC”, and complete instruction set computing or “CISC”. While I generally see RISC as a more viable standard for the future, I feel I should acknowledge that my opinion isn’t shared by many people, and give an argument in favor of CISC as well. While fewer lines of assembly code isn’t a huge advantage today considering how cheap RAM has become, one significant drawback RISC has is compiler speed. Because CISC instructions are far more similar to functions or operations one might use in a machine independent programming language like C, the compiler has to do much less work to translate source code into machine code.</p>
	<p class="blog_paragraph">Longer compiler times, or at least more complex compilers may not seem like a big deal to the end user or even most programmers, until you consider that some languages are interpreted rather than compiled. Interpreted languages such as Python and JavaScript are some of the most popular programming languages used today, and being interpreted line by line of code at run-time, can significantly diminish performance of software written in these languages. This becomes even more pronounced when running a compatibility layer such as Apple’s “Rosetta” or any of the software tools used to run Windows on ARM. Suddenly you’re having to convert source code into x86 machine code and then x86 machine code into ARM machine code line by line at run-time. This has been experienced first hand by anyone who has used Win-32 programs on an ARM based tablet like Microsoft’s Surface Pro X, or tried to run Adobe Photoshop on Apple’s new M1 chip.</p>
	<p class="blog_paragraph">That brings me to another point. Most desktop software is designed to work with CISC, not RISC. While this is changing somewhat thanks to Apple’s effort to have developers build native apps for the M1, but the M1 still has nearly two decades of catching up with the x86 platform’s software library on Mac OS. Some may remember that it also took a while for the transition from Power PC to x86 back in 2006. Popular applications like Photoshop and the myriad games available on steam already are built for the x86 platform. This is of course an advantage of x86 only, and not CISC itself.</p>
<p class="blog_paragraph">I hope you enjoyed this shorter blog post, and look forward to my post on arbitrary precision arithmetic.</p>
    </div>
</body>
